#= <br>.thick[What is deployment, anyway?]
## .thick[PyGotham 2019]
@ footer.svg

Note: breathe, Katie!

You got this

# ðŸ’ª
---
#= <br>.thick[What is deployment, anyway?]
## .thick[PyGotham 2019]
@ footer.svg

Note: breathe, Katie!

You got this

# ðŸ’ª

**Duplicate slide, for your convenience!**
---
@ whatis_copy.png


Note: 
Hi! I'm katie, and this isn't the talk you're expecting. 

---

##= .thin[What this talk isn't.]

Note: 
this isn't a talk about "the one true way" to deploy your app

This talk doesn't give specific answers, mostly, but describes the ecosystem

This talk is diving into the complexities of deployment, in essense 

---


#= .thin[What .b[is] deployment,<br>anyway?]

Note: 
We'll discuss, well ,what is deployment, anyway? 

---
#= .thin[What is .prokyon[django] deployment,<br>anyway?]
Note: and specifically within the context of deploying a django application. 

But I'm choosing django here for a reason, which will become apparaent later. 
---
#= Points of interest
## out of the box .prokyon[django]
## complexities
## helpers

Note: we'll be taking a journey today, so instead of an agenda, here are at least a few points of interest along our trip. 

We'll start by looking at exactly what comes out of the box with django

and from there discuss the complexities django has compared to other frameworks when it comes to deployment

not the complications, just the complexities. 

and discuss the helpers django has to assist you. 

---
#= .prokyon[django] 2.2.5
# .flux[python] 3.7.4

Note: the versions I'm targetting today are specifically django 2.2.5 and python 3.7.4

If you're joining me on YouTube from the year 2027, I'm sorry, things have changed since, but hopefully you find value in this talk!

---
##= no extra addons

Note: we're also just going to stick to base django

No additional features, no task management, no other helpers

Just whatever comes in stock standard django

This talk should be useful if you're anywhere from looking at django

to having your djangogirls tutorial project working on your laptop

to a more complex setup, but no extra complexities. 

---
<br><BR><BR><br><BR>
## Let's look at .prokyon[django] 
### as it comes<br>out of the box

Note: so let's get started, by taking a look at django as it comes out of the box

---
$$terminal bash
$$prompt ~/git/glasnt 
$$w
---
$$terminal bash
$$prompt ~/git/glasnt 
$$w pip install django
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
$$w 
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
$$w django-admin startproject myproject
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
django-admin startproject myproject<br>
$$prompt ~/git/glasnt
$$w 
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
django-admin startproject myproject<br>
$$prompt ~/git/glasnt
$$w cd myproject
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
django-admin startproject myproject<br>
$$prompt ~/git/glasnt
cd myproject<br>
$$prompt ~/git/glasnt/myproject
$$w
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
django-admin startproject myproject<br>
$$prompt ~/git/glasnt
cd myproject<br>
$$prompt ~/git/glasnt/myproject
$$w ls -R
---
$$terminal bash
$$prompt ~/git/glasnt
pip install django<br> 
Collecting django<br>
...<br>
Successfully installed django-2.2.5<br>
$$prompt ~/git/glasnt
django-admin startproject myproject<br>
$$prompt ~/git/glasnt
cd myproject<br>
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
manage.py  myproject<br>
<br>
./myproject:<br>
âŽ½âŽ½init__.py  settings.py  urls.py  wsgi.py<br>
$$prompt ~/git/glasnt/myproject
$$w
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w 
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w python manage.py runserver

Note: we can launch our app locally, using runserver
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
.noop[p]ython manage.py runserver<br>
Watching for file changes with StatReloader<br>
Performing system checks...<br>
System check identified no issues (0 silenced).<br><br>
.rf[You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.<br>Run 'python manage.py migrate' to apply them.]<br<br><br><br>October 04, 2019 - 17:05:24<br>
Django version 2.2.5, using settings 'myproject.settings'<br>
Starting development server at http:.noop[/]/127.0.0.1:8000/<br>
Quit the server with CONTROL-C.<br>
$$w
Note: but we get this error

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
.noop[p]ython manage.py runserver<br>
Watching for file changes with StatReloader<br>
Performing system checks...<br>
System check identified no issues (0 silenced).<br><br>
.rf[You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.<br>Run .red['python manage.py migrate'] to apply them.]<br<br><br><br>October 04, 2019 - 17:05:24<br>
Django version 2.2.5, using settings 'myproject.settings'<br>
Starting development server at http:.noop[/]/127.0.0.1:8000/<br>
Quit the server with CONTROL-C.<br>
$$w

Note: oh yay, big red error with a helpful command!

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
.noop[p]ython manage.py runserver<br>
Watching for file changes with StatReloader<br>
Performing system checks...<br>
System check identified no issues (0 silenced).<br><br>
.rf[You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.<br>Run 'python manage.py migrate' to apply them.]<br<br><br><br>October 04, 2019 - 17:05:24<br>
Django version 2.2.5, using settings 'myproject.settings'<br>
Starting development server at http:.noop[/]/127.0.0.1:8000/<br>
Quit the server with CONTROL-C.<br>
$$prompt ~/git/glasnt/myproject
$$w

Note: okay, cancel out of that..
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
.noop[p]ython manage.py runserver<br>
Watching for file changes with StatReloader<br>
Performing system checks...<br>
System check identified no issues (0 silenced).<br><br>
.rf[You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.<br>Run 'python manage.py migrate' to apply them.]<br<br><br><br>October 04, 2019 - 17:05:24<br>
Django version 2.2.5, using settings 'myproject.settings'<br>
Starting development server at http:.noop[/]/127.0.0.1:8000/<br>
Quit the server with CONTROL-C.<br>
$$prompt ~/git/glasnt/myproject
$$w python manage.py migrate
---
$$terminal bash
.cf[Operations to perform:]<br>
&nbsp; .tb[Apply all migrations:] admin, auth, contenttypes, sessions<br>
.cf[Running migrations:]<br>
&nbsp; Applying contenttypes.0001_initial... .gf[OK]<br>
&nbsp;  Applying auth.0001_initial... .gf[OK]<br>
&nbsp;  Applying admin.0001_initial... .gf[OK]<br>
&nbsp;  Applying admin.0002_logentry_remove_auto_add... .gf[OK]<br>
&nbsp;  Applying admin.0003_logentry_add_action_flag_choices... .gf[OK]<br>
&nbsp;  Applying contenttypes.0002_remove_content_type_name... .gf[OK]<br>
...<br>
&nbsp;  Applying auth.0009_alter_user_last_name_max_length... .gf[OK]<br>
&nbsp;  Applying auth.0010_alter_group_name_max_length... .gf[OK]<br>
&nbsp;  Applying auth.0011_update_proxy_permissions... .gf[OK]<br>
&nbsp;  Applying sessions.0001_initial... .gf[OK]<br>
$$prompt ~/git/glasnt/myproject
$$w

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w ls -R

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
db.sqlite3  manage.py  myproject<br>
<br>
./myproject:<br>
__init__.py  settings.py  urls.py  wsgi.py<br>
$$prompt ~/git/glasnt/myproject
$$w

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
.red[db.sqlite3]  manage.py  myproject<br>
<br>
./myproject:<br>
__init__.py  settings.py  urls.py  wsgi.py<br>
$$prompt ~/git/glasnt/myproject
$$w

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w python manage.py runserver

Note: will my project run now? 
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
.noop[p]ython manage.py runserver<br>
Watching for file changes with StatReloader<br>
Performing system checks...<br><br>
System check identified no issues (0 silenced).<br>
<br>October 04, 2019 - 17:05:54<br>
Django version 2.2.5, using settings 'myproject.settings'<br>
Starting development server at http:.noop[/]/127.0.0.1:8000/<br>
Quit the server with CONTROL-C.<br>
$$w

Note: Oh neat, no more error.  
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
.noop[p]ython manage.py runserver<br>
Watching for file changes with StatReloader<br>
Performing system checks...<br><br>
System check identified no issues (0 silenced).<br>
<br>October 04, 2019 - 17:05:54<br>
Django version 2.2.5, using settings 'myproject.settings'<br>
Starting development server at .red[http:.noop[/]/127.0.0.1:8000/]<br>
Quit the server with CONTROL-C.<br>
$$w

Note: and a helpful little message telling us where we're running
---
@= djangorocket.png
---
@= djangoadmin.png
Note: and we have the much loved django admin

---
#= .prokyon[django]
## good local development story

Note: we can get our app running locally really well. 

and a lot of this boils down to
---
<br><br><br>
# .code[runserver]

Note: runserver does everything we need to in our local system. 
---
<br><br><br>
# .code[runserver]
### local web server 
---
@= runserver_00.png
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/django-admin/#runserver)
---
@= runserver_00a.png
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/django-admin/#runserver)
Note: As the documentation says, runserver starts a lightweight development web server on your ocal machine. 
But. And there's a big but.
---
@= runserver_01.png
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/django-admin/#runserver)
Note: do not use this server in a production setting. 

---
@= runserver_02.png 
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/django-admin/#runserver)
---
<br>
# .quote["We're in the business of<br>making Web frameworks,<br>not Web servers"]
### - .prokyon[django] documentation
Note: I want to pull this out and elaborate. 

Django is an extremely stable, production ready, web framework.

Django is very good at being a web framework. 

The fact that it provides any local web server functionality at all is amazing, but the fact that it calls out that it's not for production is also very very good. 

We'll discuss a selection of webservers you should use in production a bit later.  

But, there are a few new terms that we've just hit that we should take time to clarify. 
---
#= What is 'production'?

Note: 
What is production, anyway?

I've asked this question to a bunch of python practioneres, many of whom have a decade or more of experience

And the question leaves them thinking. 

Why do we call it production? 

_ _Riff here_ _

1950's paper comparing to a production line. 

In the current web sense, you could compare it to a theatre production. 

_ _End riff_ _

In essense: production is live is the one your users access.

---
#= What is a web server?
Note: 
Also, what is a web server? 

Thankfully this one is more aptly named. 

A web server serves websites. 

There are local web servers, like runserver, or there are production-grade web servers, that we'll discuss later. 

The website is the service that responds when you enter a website URL into your browser, and deals with the HTTP protocol, handshakes, content types, . 


---
<br><br><br>
# .code[runserver]
### local web server<br>+ static server 
Note: Runserver is our local web server, but runserver also handles serves our static. 
---
#= What is 'static'?
### or 'static assets', or 'assets'

Note: Static, assets, or static assets 

refers to the unmoving parts of our web site, relative to the dynamic parts. 

Assets miight be pictures, video, uploaded user files

that we can store locally on disk and serve as we need them. 


---
@= staticfiles_00.png
vv [âžš](https://docs.djangoproject.com/en/2.2/howto/static-files/#serving-static-files-during-development)
Note: but only if
---
@= staticfiles_00a.png
vv [âžš](https://docs.djangoproject.com/en/2.2/howto/static-files/#serving-static-files-during-development)

Note:
we have our debug set to true and we're using the staticfiles middleware. 

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w 
Note: Which if we check out settings file we have both.  
---

$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w cat myproject/settings.py |grep staticf
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
cat myproject/settings.py |grep staticf<br>
&nbsp; &nbsp; 'django.contrib.staticfiles',<br>
$$prompt ~/git/glasnt/myproject
$$w
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
cat myproject/settings.py |grep staticf<br>
&nbsp; &nbsp; 'django.contrib.staticfiles',<br>
$$prompt ~/git/glasnt/myproject
$$w cat myproject/settings.py | grep DEBUG
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
cat myproject/settings.py |grep staticf<br>
&nbsp; &nbsp; 'django.contrib.staticfiles',<br>
$$prompt ~/git/glasnt/myproject
cat myproject/settings.py | grep DEBUG<br>
DEBUG = True<br>
$$prompt ~/git/glasnt/myproject
$$w
---
@= staticfiles_00.png
vv [âžš](https://docs.djangoproject.com/en/2.2/howto/static-files/#serving-static-files-during-development)
Note: but, as with the runserver, there's a note telling us
---
@= staticfiles_01.png
vv [âžš](https://docs.djangoproject.com/en/2.2/howto/static-files/#serving-static-files-during-development)
Note: this is not for production use. 

This is a helper for local development, so we'll need to substitute with something production grade later on,. 

While we're also looking at our default settings file for our other helper
---
<br><br><br>
# .code[DATABASES]
### default: sqlite

Note: the default for our database has already been set for a local sqlite database. 

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
.red[db.sqlite3]  manage.py  myproject<br>
<br>
./myproject:<br>
__init__.py  settings.py  urls.py  wsgi.py<br>
$$prompt ~/git/glasnt/myproject
$$w
Note: We saw this earlier in our files. 

---
$$terminal bash
$$prompt ~/git/glasnt/myproject
cat myproject/settings.py | grep sqlite -C2<br>
DATABASES = {<br>
&nbsp; &nbsp; 'default': {<br>
&nbsp; &nbsp; &nbsp; 'ENGINE': 'django.db.backends.sqlite3',<br>
&nbsp; &nbsp; &nbsp; 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),<br>
&nbsp; &nbsp; }<br>
}<br>
$$prompt ~/git/glasnt/myproject
$$w
Note: this was created due to the default DATABASES setting where sqlite is defined as the default backend. 

---

@= sqlite_00.png
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/databases/#sqlite-notes)
Note: and, again, as per the documentation, sqlite is great in a 

---
@= sqlite_01.png
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/databases/#sqlite-notes)
Note: development environment. 
---
#= .prokyon[django]
## ease of use in development
Note: django a really good development story

but all the helpers we used in development cannot and should not be used
in production. 

so we can't use any of these helpers 
---

<br><BR><BR>
# .prokyon[django]
## complex in production

Note: which makes our production use.. complex. 

not complicated, but just complex. 

django doesn't provide you with a webserver or database that's production ready

So you have to provide your own. 

And if you aren't familiar with the production-grade offerings here, you'll end up confused. 

Or worse, leaning towards using the development systems in production. 

However, 

Now is an important time to mention something important. 

---
<br><BR><BR>
# .poly[Flask]
## simpler in production<br>.h3[(comparatively)]
Note: 
Compare the out of the box functionality of django to something like flask

A lot of tutorials you see out there that say

"How to deploy python in production!"

Often use flask as the target.

Just copy up your code somewhere and run. Easy!

This is because of one simple fact
---
#= .b[state]

Note: django is a stateful application. It has a database out of the box and static assets. 

Flask, by default, does not. The sample "Hello world" doesnt' require a database or images, so it's so simpler to deploy.

---

#= stateful applications
## complex in production

Note: any application that has state is complex in production. 

This is why I chose to use django for my context

If I'd chosen flask, the discussion of deployment could be **really easy**

buyt it's not just django; any time you care about persistence you add complexity to your deployments. 

And, funnily enough, this is also mentioned in the docs

---
@= deployment_00.png
vv [âžš](https://docs.djangoproject.com/en/2.2/howto/static-files/deployment/#serving-static-files-in-production)

Note: This section which discusses static deployment has this **wonderful gem**

---

@= deployment_01.png
vv [âžš](https://docs.djangoproject.com/en/2.2/howto/static-files/deployment/#serving-static-files-in-production)

Note: every production setup will be a bit different. 


---

#= .quote["Every production setup<br>will be a bit different"]
### - .prokyon[django] documentation
Note:
I'm not sure who added this line to the documentation

which has been in the docs for a decade at this point

but whoever it was was such a smart cookie. 

This is so so important.

So important it's on it's own slide. 

But this statement is so so true. 

---


#= .quote["It depends."]
### - every deployment talk ever 

Note: 

Nearly every talk I've seen on deployment includes a line like

it depends

When trying to tell you the "one true way" to do django deployments. Heck, I've seen a talk with this exact title. 

Because it's true. 

But I'm not going to use that line. I'm going to use another one. 

---

#= .quote["I'm a sysadmin,<br>I'm not your sysadmin."]
### - @glasnt

Note: I prefer this line. 

I'm a sysadmin, I'm not your sysadmin. 

being a play on the line "I'm a lawyer I'm not your lawyer".

I've been a sysadmin, operations engineer, SRE, whatever you want to call it

on and off for nearly the last decade. 

I've worked for 

... web hosting providers

... platforms as a service

and now

infrastructure as a service. 

And each and every deployment is different and unqiue and beautiful and complex.

--- 
<br><br>
# to deploy a stateful app: 
Note: and for any stateful application, you have at the bare minimum three major segments
---
<br><br>
# to deploy a stateful app:
## run web framework
Note: you need a way to run the web framework, whatever it is

---
<br><br>
# to deploy a stateful app:
## run web framework<br>connect to a database
Note: a way to connect to your database
---
<br><br>
# to deploy a stateful app:
## run web framework<br>connect to a database<br>serve static files
Note: and a way to serve whatever static apps you have. 

this exact trifecta is the same for Django. 
---
<br><br>
# to deploy .prokyon[django]: 
## run django<br>connect to a database<br>serve static files
Note: you need to run the web  framework, connect to a database, and serve the static. 

These are the same requirements are for any stateful application

Therefore, we can explore what a stateful application deployment means without
having to keep outselves within django itself

But, thankfully for us using django, we have some helpers. 

---
<br><BR>
# .prokyon[django] helpers
## WSGI<br>.c[migrate]<br>.c[collectstatic]

Note: in order they are wsgi compatitbility, the migrate command, and the collect static command. 

The rest of this talk will be describing how these helpers work. 

Which will help us in exploring the options we have for deployment 
---
#= WSGI
## Web Server Gateway Interface
### ðŸ”Š *Ëˆ(h)wiskÄ“*

Note: WSGI is an acronym for 

the web server gateway interface 

and is python standard for web servers

---

#= What is WSGI?

Note: 

WSGI is a standard interface for python applications to talk to a webserver. 


The standard was proposed back in 2003 as PEP-333, as a prompt to standardaise the interface between web servers and python web frameworks. 



---
@= wsgi_00.png
Note: again, as per the docs

i love the docs

django's primary deployment platform

is wsgi 

! as of django 2.2!!

And as stated earlier, we are looking at Django 2.2, so for those on the recording, there may be something different now :D *wink* 

---
@= wsgi_01.png

Note: but as noted: the start project command sets up a simple default WSGI condig for you. 

Which we can see from our project earlier. 

---

$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w
Note: in our terminal, looking at the files we have 
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
$$w ls -R
Note: we can list our files
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
db.sqlite3 manage.py  myproject<br>
<br>
./myproject:<br>
âŽ½âŽ½init__.py  settings.py  urls.py  wsgi.py<br>
$$prompt ~/git/glasnt/myproject
$$w

Note: 
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
db.sqlite3 manage.py  myproject<br>
<br>
./myproject:<br>
âŽ½âŽ½init__.py  settings.py  urls.py  .red[wsgi.py]<br>
$$prompt ~/git/glasnt/myproject
$$w

Note: and see indeed there is a wsgi.py file 
---
$$terminal bash
$$prompt ~/git/glasnt/myproject
ls -R<br>
.:<br>
db.sqlite3 manage.py  myproject<br>
<br>
./myproject:<br>
âŽ½âŽ½init__.py  settings.py  urls.py  wsgi.py<br>
$$prompt ~/git/glasnt/myproject
$$w cat myproject/wsgi.py

Note: the contents of which... 
---
$$terminal bash
WSGI config for myproject project.<br><br>It exposes the WSGI callable as a module-level variable named 'application'.<br>For more information on this file, see<br>https:.noop[/]/docs.djangoproject.com/en/2.2/howto/deployment/wsgi/<br>"""<br>import os<br><br>from django.core.wsgi import get_wsgi_application<br><BR>os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')<br><BR>application = get_wsgi_application()<br>
$$prompt ~/git/glasnt/myproject
$$w

---

#= Deploy a .prokyon[django] app<br>with a WSGI webserver
---

#= WSGI webservers:
## .nl[[uWSGI](https://uwsgi-docs.readthedocs.io/en/latest/)]
## .nl[[gunicorn](https://gunicorn.org)]


vv [Type UWSGI, Press Enter, what happens?](https://www.youtube.com/watch?v=YoUZIzPGKT8) P. James, [Secrets of a WSGI master](https://www.youtube.com/watch?v=CPz0s1CQsTE) G. Dumpleton
Note: some of the options you have include microwsgi and gunicorn

Both of these webservers have their own cache of documentation, talks, and resources, which my slides link to. 



---

#= How do you deploy WSGI webserver?

Note: but how do you deploy a wsgi websever

There are so many options

and what you choose is going to dictate some of the options available to you later. 
---
#= .so[How do you deploy WSGI webserver?]
Note: but I have a better question

---
<br><BR>
## How much<br>custom infrastructure<br>do you want?
Note: how much custom infrastrcutre do you want? 

Because as we saw before, every production setup is a bit different

but there are plenty of options out there for you if you want to use a template that works for 
80% of cases

and if you only have a standard django app, then these are going to work for you. 
---

<br><BR>
## .so[How much<br>custom infrastructure<br>do you want?]
Note: and probably more importantly. 
--- 
<br><BR>
## How much<br>infrastructure management<br>do you want<br>to do yourself?

Note: how much infrastrcutre management do you want to do yourself?

If you are a django developer, then you probably want to develop django

you don't want to be spending your time trying to manage your infrastrcture

it's super interesting, sure, to setup your own physical server, your own network, your own server, your own redunant power, your own everything. 

but when you want is just to get your application online, then why not pay someone who has spent the time to setup a way that works for 80% of websites 

In our setup, we don't have anything custom, and we don't have any strong opinions about anything (yet), so why not let someone else manage things for you?

put in more simpler terms

---
##= What<br>do you want<br>to worry about?


Note:  what do you want to worry about


Thankfully, you can pay to take your worry away. 

---

#= Managed hosting:
## Platform as a Service
## Infrastructure as a Service
vv * non-exhaustive

Note: in the managed hosting world, for the complexity of project we're talking about, there are two major options

PaaS and IaaS
---

#= Managed hosting:
## PaaS
## IaaS
vv * non-exhaustive

Note: you'll often seen these abbreviated as Paas or IaaS, because words are getting long and we're busy technologists. 

And yes, this is non-exhaustive. Within the scope of deploying a django application, these are the two major options. 
---

#= Other options: 
## ~~Functions as a Service~~
## ~~Custom hardware~~

Note: 
You could go as detailed as running your app on a server you have in your own home or business ("on-prem") (that make your own everything scenario I mentioned earlier)

 or trying to squeeze django into a function as a service, 

but these are the 20% of cases. The non-standard cases. 

I'm going to focus on the ones that are much more suited for django, and more suited to our unopinionated django app

---
<BR><BR>
# Platform as a Service
### worry about:<br>your .prokyon[django] app, data 

vv Example providers: Heroku, Divio, Google Cloud, PythonAnywhere

Note: in general your platforms as service are going to be places where you provide your code to them, often fit to some sort of template, which normally includes the command to run to get your app working. This will often be uwsgi or guniconr

---
<br><BR>
# Platform as a Service
### managed for you: <br>web server, operating system,<br>hardware, storage, networking...
vv Example providers: Heroku, Divio, Google Cloud, PythonAnywhere

Note: the things that will be managed for you include the web server (often included in whatever template you have), the operating system, the physical hardware, the storage, networking, and a whole host of other things. 

On the otherhand, if you have opinions about some of the earlier elements in this, you can jump down into 
---
<BR><BR>
# Infrastructure as a Service
### worry about:<br>your .prokyon[django] app, data<br>web server, operating system
vv Example providers: Google Cloud, Amazon Web Services, Azure
Note: IaaS. Where you can worry about your web server and operating system. 

---
<BR><BR>
# Infrastructure as a Service
### managed for you: <br>hardware, storage, networking...
vv Example providers: Google Cloud, Amazon Web Services, Azure
Note: and you pay for someone else to manage the hardware, storage, etc. 

Now this is very very much an overgeneralisation, as there is an entire other talk on the complexities of infrastrcutre as a service. 

but there is a reason I mentioned this 

---
<br><br>
# to deploy .prokyon[django]: 
## run django<br>connect to a database<br>serve static files
Note: our list of things we need to deploy a django app 

---
<br><br>
# to deploy .prokyon[django]: 
## .so[run django]<br>connect to a database<br>serve static files
Note: we've covered one

And the next one is a database. 
and here's the secret
---

#= .code[makemigrations<br>migrate]

Note: these two commands, in my own personal opinion, two of the greatest features of django

Oh, I mean having a dynamic web admin is pretty sweet, but these two commands are just choice. 

---

#= .code[migrate/makemigrations] created to<br>reduce developer toil

Note: 
The whole concept of automating the migration framework was design to reduce developer toil 

the migrations framework is designed to create the required database commands in order to make your models into real tables. 

And it doesn't matter which database you choose, django is a database agnostic web framework, so you don't have to worry.

---
$$terminal bash
.cf[Operations to perform:]<br>
&nbsp; .tb[Apply all migrations:] admin, auth, contenttypes, sessions<br>
.cf[Running migrations:]<br>
&nbsp; Applying contenttypes.0001_initial... .gf[OK]<br>
&nbsp;  Applying auth.0001_initial... .gf[OK]<br>
&nbsp;  Applying admin.0001_initial... .gf[OK]<br>
&nbsp;  Applying admin.0002_logentry_remove_auto_add... .gf[OK]<br>
&nbsp;  Applying admin.0003_logentry_add_action_flag_choices... .gf[OK]<br>
&nbsp;  Applying contenttypes.0002_remove_content_type_name... .gf[OK]<br>
...<br>
&nbsp;  Applying auth.0009_alter_user_last_name_max_length... .gf[OK]<br>
&nbsp;  Applying auth.0010_alter_group_name_max_length... .gf[OK]<br>
&nbsp;  Applying auth.0011_update_proxy_permissions... .gf[OK]<br>
&nbsp;  Applying sessions.0001_initial... .gf[OK]<br>
$$prompt ~/git/glasnt/myproject
$$w
Note: 

These are the migrations we generated earlier

these create the data strcutures required for the the django admin to work

you can see it in the filenames - admin, auth (authentication), sessions. 

But to migrate data, you need a database.  

and here's the secret. 
---
##= Managed databases<br>are just a specialised<br>*aaS

Note: managed databases are just specalised "as a service"

whatever bucket you want to put them in depends on your definition, if they IaaS or Paas or even Software as a service, but either way, they're a service. 




---
<br><BR>
## Managed databases
### worry about:<br> your data models
vv Example providers: your PaaS or IaaS provider
Note: you define your data models in your app 
---

<br><BR>
## Managed databases
### .prokyon[django] worries about:<br>generating and applying migrations
vv Example providers: your PaaS or IaaS provider
Note: making the migrations and applying them to whatever database you choose is django's problem. More on that a bit later. 
---
<br><BR>
## Managed databases
### managed for you:<br>storage, backups, persistence, maintenance...
 
vv Example providers: your PaaS or IaaS provider

Note: your database host will often handle everyhitng from backups to storage (including scaling storage, which is often very good. 

These will often be available from your web server provider, which is often a very good idea because the closer your web server and database the faster you can send data between the two parts of your application. 

ALTTODO
Are you a pyhton developer or a Database adminsitrator?

If you'd rather have more time for python, use the managed database. 
ENDALTTODO

TODO

more here something along the lines of

there is no reason not to use a managed database any more

managed databases are a solved problem, pay for one and get the benefits

a lot of people use databases, so a lot of work has gone into them

pay just a little bit and you often get: persistence, backups, maintenance windows, more so: you don't have to manage it. 

heck, some now days even automatically expand and the providers handle this without downtime for you

this and your domain name might be the only thing you end up paying for in a smaller stack, but it's worth it. 

ENDTODO


---
#= Which database?
---


@= database_00.png
vv [âžš](https://docs.djangoproject.com/en/2.2/ref/databases/)

Note: the docs are useful here, expect there's a super important note

---

@= database_01.png

vv [âžš](https://docs.djangoproject.com/en/2.2/ref/databases/)

Note: not all databases backends are alike, and there have been some design considerations. 

---
<br>
# Supported databases
## PostgreSQL 9.4+ (psycopg2 2.5.4+)<br>MySQL 5.6+ (InnoDB)<br>Oracle 12.1+<br>SQLite 3.8.3
vv [limitations](https://docs.djangoproject.com/en/2.2/ref/databases/), [oracle + django](https://slides.com/iqbaltalaatbhatti/oracle-django)

Note: django does support a number of databases, including postgresql, mysql, oracle, and sqlite. 

There is also third party support for a number of other databases, but again

--- 
##= What<br>do you want<br>to worry about?

Note: what do you want to worry about? 

If you already have a database expert, choose the one they know. 
If you have a preferred one, choose that. 

Otherwise

---
<br><BR><BR>
### No opinion?
# Choose PostgreSQL

Note: choose postgresql

Shock I know right. I'm actually telling you something solid. 

But it's not without reason. 

---

@= database_02.png

Note: the docs specifically point this out. 

django is a database agnostic web framework

but django provides support for a number of datatypes that only work in postgressql. 

The ability for other databases to have as much bredth in functionality is limited only by community contribution

at the time of recording, postgres has the most contribution

If you want your preferred database to have more support, help support it by writing the functionality :)

---
#= to deploy .prokyon[django]: 
## .so[run django<br>connect to a database]<br>serve static files

Note: and now to the last section in our deployment trifecta 
---

#= .code[collectstatic]

Note: the helper here is collectstatic

---

#= static asset management
## an entire talk

vv ["Assets in Django without losing your hair", J. Kaplan-Moss](https://www.youtube.com/watch?v=E613X3RBegI)

Note: this is literally an entire talk, and thankfully there was a talk focussing only on this at PyCon this year

---

#= asset management options:

## simple assets
## cloud storage
## media uploads
## asset compilation
vv ["Assets in Django without losing your hair", J. Kaplan-Moss](https://www.youtube.com/watch?v=E613X3RBegI)


Note: Jacob Kalplan-Moss details four scenarios, 

simple assets

cloud storage

media uploads

and the more complex asset compilation

as ways of hosting static assets. 

if you chose a chose a IaaS provider earlier, they probably offer some sort of cloud storage, which is super useful to have, again, to keep everything physically close. 

If you went with the PaaS, perhaps the simple asset solution is for you. 

TODO

more here, something long the lines of: 

out of all the tech I've discussed so far, cloud storage is the oldest and most solid

AWS S3 launched in 2006. That's 13 years ago.

storing media objects is a foundational service provided by any cloud provider. 

and it's totally okay to use

the scariest thing when I first came across s3 was the fact that I had to use a global bucket name. Like, a name that had never been used before
but that's okay

the way this works means that the name must be unique for every reference

use this foundational service of the current internet age

and make sure that when you name your bucket it's not just your app's name or your internet name because once you use that name it's gone forever and you'll probably want to change your naming scheme at once point so if it's your first one just make sure it's not a super cool name. 

ENDTODO

--- 

<br><br>
# to deploy .prokyon[django]: 
## .so[run django<br>connect to a database<br>serve static files]
Note: so we've covered each of the three major tenants. 

So

---
#= actually deploying

Note: actually deploying. 

we're finally there. 

---
##= [copy code to host]<br>.c[python manage.py migrate]<br>.c[python manage.py collectstatic]<br>[start web server]

Note: here it is. 

~

.noop[c]opy your code to wherever you're hosting

run your two management commands

and start your web server, whichever that is. 

~

I know. This doesn't seem like a lot. 

But given the last XX minutes I spent describing all this, hopefully you now have a greater understanding of the complexity. 
---
<br><br><BR>
# Things I didn't mention
Note: there's so much more to this topic that I just can't even hope to cover. 
--

### continuous deployment, monitoring, scaling, logging,<br>high availablilty, load balancing, secrets,<br>orchestration, zero downtime deployments,<br>blue/green deployments, A/B testing, containers,<br>configuration management, automation... 

Note: 
Nearly each of these topics is their own entire *conference* worth of material. 

And there are many many opinions about *when* to run the four commands I mentioned earlier. 

But hopefuully I've been able to help you just see a bit behind the curtain of deployment. 

And shown you that is it is complex, but not as complicated as you might think. 

---
#= <br>Thanks!
@ footer.svg
Note: I am sure there are many opinions that this talk has surfaced

so for the comfort of the audience and the next speaker

.noop[p]lease follow me out in to the hallway and we can have a chat. 

I'm also available on email and twitter if you want to discuss more later. 

Thanks!
